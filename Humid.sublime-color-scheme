{
  "name": "Humid",
  "author": "https://github.com/frou",

  "variables": {
    "black": "#000000",
    "blue": "#5a70a9",
    "gold": "#ad9361",
    "green": "#6a8856",
    "grey": "#3f3938",
    "grey_light": "#4f4d4d",
    "orange": "#ae7337",
    "orange_punchy": "#ff8000",
    "purple": "#995a64",
    "purple_punchy": "#fe3bff",
    "red": "#b75b4e",
    "red_punchy": "#bb0000",
    "slate": "#211e1e",
    "slate_light": "#60605a", // TWIN: "kind_namespace_color" in Adaptive theme customisation
    "steel": "#8c8c99",
    "white": "#ffffff",
    "white_faded": "#dadada",
    "yellow_punchy": "#eed600",

    // Overrule ST where it picks what I feel is the wrong colour from those used in
    // this colour scheme to be a given *ish colour.
    //
    // REF: https://www.sublimetext.com/docs/minihtml.html#predefined-variables
    "--redish": "var(red)",
    //"--greenish": "var()",
    //"--bluish": "var()",
    "--yellowish": "var(gold)",
    //"--pinkish": "var()",
    "--cyanish": "var(steel)",
    //"--orangish": "var()",
    "--purplish": "var(purple)",
    //"--foreground": "var()",
    //"--background": "var()",
    //"--accent": "var()",
  },

  // REF: https://www.sublimetext.com/docs/color_schemes.html#global_settings
  "globals": {
    // @todo Use "popup_css" to make "Kind" icons in popups (e.g. the hover popup that shows Definition location) use my preferred colouring.
    // @body REF: discord://discord.com/channels/280102180189634562/280157067396775936/1053270072619180052
    // @body REF: https://github.com/sublimehq/sublime_text/issues/2935
    // @body REF: https://github.com/sublimehq/sublime_text/issues/3650
    // @body REF: https://github.com/sublimehq/sublime_text/issues/3651
    //
    // TWIN: User/Adaptive.sublime-theme
    //
    //"popup_css": "#show-definitions > span.kind_function { ... } ...",

    "foreground": "var(white_faded)",
    "background": "var(slate)",

    "caret": "var(white)",

    "invisibles": "var(grey_light)",

    "line_highlight": "var(grey)",

    "selection": "var(grey)",
    "selection_border": "var(grey)",
    "selection_corner_style": "square",

    "gutter": "var(slate)",
    "gutter_foreground": "var(slate_light)",

    "find_highlight_foreground": "var(black)",
    "find_highlight": "var(yellow_punchy)",

    "brackets_options": "glow",
    "brackets_foreground": "var(orange_punchy)",

    "bracket_contents_options": "glow",
    "bracket_contents_foreground": "var(orange_punchy)",

    "tags_options": "glow",
    "tags_foreground": "var(yellow_punchy)",

    "line_diff_width": "2",
    "line_diff_added": "color(var(green) lightness(- 25%))",
    "line_diff_modified": "color(var(slate_light) lightness(- 15%))",
    "line_diff_deleted": "color(var(red) lightness(- 25%))",

    "misspelling": "var(red_punchy)",
    // "fold_marker": "var(white)",
    "accent": "var(blue)",
  },

  // NOTE: Operator precedence (descending) in scope selectors:
  //   ( )  Grouping
  //   &    Intersection
  //   -    Asymmetric Difference (Relative Complement)
  //   |    Union
  //   ,    Comma
  //
  // REF: https://stackoverflow.com/questions/33562253/sublime-text-scope-selector-operators
  // REF: https://www.sublimetext.com/docs/selectors.html
  //
  // By convention, use comma (lowest precedence) to separate different
  // languages in a scope selector.
  //
  "rules": [
    // ~~~~~~~
    // Comment
    // ~~~~~~~
    {
      "scope": "comment - ((source.clojure | source.edn) & comment.punctuation.comma)",
      "foreground": "var(slate_light)"
    },
    {
      // Stuff that isn't misclassified, but I want it to have the same colour as `comment`, just because.
      "scope": "source.zig string.unquoted punctuation.definition.string.begin",
      "foreground": "var(slate_light)"
    },
    // ~~~~~~~~
    // Constant
    // ~~~~~~~~
    {
      "scope": "constant - ((source.js | source.jsx | source.ts | source.tsx) & (meta.import | meta.export) & constant.other)",
      "foreground": "var(red)"
    },
    {
      // Stuff that isn't misclassified, but I want it to have the same colour as `constant`, just because.
      "scope": "text.build-results markup.pointing-carets , text.xml.kajiki & (punctuation.section.interpolation.begin | punctuation.section.interpolation.end) , text.build-results.go keyword.pseudo-linter-name , source.erlang punctuation.definition.sequence , source.file-pattern keyword.operator.wildcard",
      "foreground": "var(red)"
    },
    // ~~~~~~
    // Entity
    // ~~~~~~
    {
      "scope": "entity - (source.c++ entity.name.function punctuation.accessor , source.go entity.name.namespace , source.ruby entity.other.inherited-class punctuation.accessor.double-colon)",
      "foreground": "var(orange)"
    },
    {
      // Stuff that isn't misclassified, but I want it to have the same colour as `entity`, just because.
      "scope": "source.file-pattern support.constant , source.ocaml & (punctuation.label.parameter.required)",
      "foreground": "var(orange)"
    },
    // ~~~~~~~
    // Invalid
    // ~~~~~~~
    {
      "scope": "invalid",
      "background": "var(red_punchy)",
      "foreground": "var(white_faded)"
    },
    {
      "scope": "invalid.deprecated",
      "background": "var(red)",
      "foreground": "var(white_faded)"
    },
    // ~~~~~~~
    // Keyword
    // ~~~~~~~
    {
      "scope": "keyword - keyword.operator - ((source.js | source.jsx | source.ts | source.tsx) & keyword.declaration.function.arrow , (source.ts | source.tsx) & meta.type keyword.declaration.function , source.python keyword.control.import.relative , source.shell keyword.control.conditional.patterns) , source.regexp keyword.operator , source.file-pattern keyword.operator.logical , source.regexp-replace keyword.operator",
      "foreground": "var(green)"
    },
    {
      // NOTE: For programming languages, this Colour Scheme intends that typical punctuation-like
      // operators e.g. `+ / && =` should never be coloured (because they already look distinct enough
      // due to the shapes of the glyphs alone), which is why the scope `keyword.operator` is negated
      // in the previous rule.
      //
      // However, this Colour Scheme does intend that word-like operators e.g. `and not in instanceof`
      // should be coloured.
      //
      // Not all Syntax Definitions establish any distinction in scopes between those two kinds of
      // operators, and so some .sublime-syntax files additionally need to be Overridden (the
      // modifications usually being the addition of the scope `keyword.operator.word.*`).
      // Among ST's stock Syntax Definitions, some that currently need such an override file are:
      //   - Erlang
      //   - Ruby
      //   - TypeScript
      // REF: https://github.com/sublimehq/Packages/pull/2090
      "scope": "keyword.operator.word , keyword.operator.js , source.python keyword.operator.logical , source.sql & (keyword.operator.logical | keyword.operator.assignment)",
      "foreground": "var(green)"
    },
    {
      // Stuff I feel should be classified as `keyword` but I don't control the syntax definitions. Make them look like it at least.
      "scope": "source.python storage.modifier - storage.modifier.conversion - storage.modifier.debug , (source.js | source.jsx | source.ts | source.tsx) & (variable.language.super | variable.language.this | storage.modifier - (meta.type | storage.modifier.array | storage.modifier.optional | storage.modifier.definite)) , source.ruby entity.name.function.prepocessor",
      "foreground": "var(green)"
    },
    {
      // Stuff that isn't misclassified, but I want it to have the same colour as `keyword`, just because.
      "scope": "source.css support.constant , source.makefile variable.language.automatic , (source.js | source.jsx | source.ts | source.tsx) & (variable.language.global | variable.language.arguments) , source.file-pattern punctuation.separator , source.regexp-replace variable.language.backref",
      "foreground": "var(green)"
    },
    // ~~~~~~
    // Markup
    // ~~~~~~
    {
      "scope": "markup",
      "foreground": "var(steel)"
    },
    {
      // Stuff I feel should be classified as `markup` but I don't control the syntax definitions. Make them look like it at least.
      "scope": "source string constant.other.placeholder",
      "foreground": "var(steel)"
    },
    {
      // Stuff that isn't misclassified, but I want it to have the same colour as `markup`, just because.
      "scope": "source.ocaml & (punctuation.label.argument | meta.path) , (source.clojure | source.edn) & constant.other.keyword , source.json.sublime.color-scheme meta.scope-selector.sublime & (keyword.operator | punctuation.section.group) , source.css meta.selector & (entity.other.attribute-name.class | entity.other.pseudo-class) , meta.diff , source.erlang & (constant.other.symbol | constant.language.exception | constant.language.boolean) , (source.js | source.jsx | source.ts | source.tsx) & (entity.other.attribute-name.documentation | meta.string meta.interpolation punctuation.section.interpolation) , source.shell.bash meta.string meta.interpolation.parameter , source.python support.variable.magic , (source.jsx | source.tsx) & meta.tag.name entity.name.tag - entity.name.tag.native , source.regexp-replace variable.language.match , source.sml variable.other.member",
      "foreground": "var(steel)"
    },
    // ~~~~~~~
    // Storage
    // ~~~~~~~
    {
      "scope": "storage - (source.python storage.modifier.debug , (source.ts | source.tsx) & storage.modifier.array)",
      "foreground": "var(gold)"
    },
    {
      // Stuff I feel should be classified as `storage` but I don't control the syntax definitions. Make them look like it at least.
      "scope": "source.python & ((meta.function.parameters.annotation | meta.function.annotation.return) & (meta.generic-name | support.type) | meta.statement.exception.catch support.type.exception | meta.function.annotation.return constant.language | support.type - variable.function) , source.c support.type , (source.js | source.jsx | source.ts | source.tsx) & (variable.type | support.type - support.type.object | support.class.builtin) , (source.ts | source.tsx) & (meta.type | meta.type-alias | meta.generic) & support.class",
      "foreground": "var(gold)"
    },
    {
      // Stuff that isn't misclassified, but I want it to have the same colour as `storage`, just because.
      "scope": "entity.other.inherited-class - (source.ruby punctuation.accessor.double-colon) , source.css meta.selector & (entity.name.tag | entity.other.pseudo-element) , text.git.commit markup.heading.subject , (source.js | source.jsx | source.ts | source.tsx) & (keyword.declaration.async.js | entity.name.function.constructor) , (text.xml | text.html | source.jsx | source.tsx) & entity.name.tag , source.ruby & (support.other.namespace | support.class)",
      "foreground": "var(gold)"
    },
    // ~~~~~~
    // String
    // ~~~~~~
    {
      "scope": "string - (source.shell.bash meta.function-call.arguments.shell string.unquoted.shell , source.shell.bash meta.sequence.shell string.unquoted.shell , (source.clojure | source.edn) & string.regexp punctuation.definition.string.begin keyword.operator.macro)",
      "foreground": "var(blue)"
    },
    {
      // Stuff I feel should be classified as `string` but I don't control the syntax definitions. Make them look like it at least.
      "scope": "source.shell.bash meta.string & (meta.interpolation.command | meta.interpolation.parameter) & (punctuation.definition.variable | punctuation.section.interpolation.begin | punctuation.section.interpolation.end) , source.python comment.block.documentation",
      "foreground": "var(blue)"
    },
    {
      // Nullify the SQL syntax highlighter kicking in inside strings in other languages. That such a feature is possible is a cool technical achievement, but subjectively I don't find it helps overall readability.
      "scope": "source.python meta.string.python source.sql & (source | comment | constant | entity | keyword | markup | storage | string | support)",
      "foreground": "var(blue)"
    },
    // ~~~~~~~
    // Support
    // ~~~~~~~
    {
      "scope": "support - ((source.js | source.jsx | source.ts | source.tsx) , source.go support.type.builtin , source.python entity.name.function , source.erlang support.namespace) , (source.js | source.jsx | source.ts | source.tsx) & (support.function - support.function.node - invalid.deprecated)",
      "foreground": "var(purple)"
    },
    {
      // Stuff I feel should be classified as `support` but I don't control the syntax definitions. Make them look like it at least.
      "scope": "source variable.function - ((source.clojure | source.edn) & (meta.namespace | punctuation.accessor)) , constant.language.shebang , source.python variable.annotation",
      "foreground": "var(purple)"
    },
    {
      // Stuff that isn't misclassified, but I want it to have the same colour as `support`, just because.
      "scope": "(source.json | source.yaml | source.ini) & meta.mapping.key string , source.toml entity.name.tag , (text.xml | text.html | source.jsx | source.tsx) & entity.other.attribute-name , source.clojure keyword.declaration.namespace , source.file-pattern & (constant.language | variable.language.wildcard)",
      "foreground": "var(purple)"
    },

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Basic Styling
    // REF: https://www.sublimetext.com/docs/scope_naming.html#markup
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"name": "markup bold",                  "scope": "markup.bold", "font_style": "bold"},
    {"name": "markup italic",                "scope": "markup.italic", "font_style": "italic"},
    {"name": "markup underline",             "scope": "markup.underline", "font_style": "underline"},
    {"name": "markup bold/italic",           "scope": "markup.italic markup.bold | markup.bold markup.italic", "font_style": "bold italic"},
    {"name": "markup bold/underline",        "scope": "markup.underline markup.bold | markup.bold markup.underline", "font_style": "bold underline"},
    {"name": "markup italic/underline",      "scope": "markup.underline markup.italic | markup.italic markup.underline", "font_style": "italic underline"},
    {"name": "markup bold/italic/underline", "scope": "markup.bold markup.italic markup.underline | markup.bold markup.underline markup.italic | markup.italic markup.bold markup.underline | markup.italic markup.underline markup.bold | markup.underline markup.bold markup.italic | markup.underline markup.italic markup.bold", "font_style": "bold italic underline"},

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Things that should GLOW
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
      "scope": "source.erlang & (punctuation.separator.expressions | punctuation.separator.clauses | punctuation.terminator.clause) , source.zig & (constant.language.undefined | variable.language.ignore) , source.sml support.function.toplevel-env.dangerous",
      "font_style": "glow"
    },

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Jinja Templating
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
      "scope": "text.jinja & (meta.statement.jinja | comment.block.jinja | comment.line.jinja)",
      "background": "var(black)"
    },
    {
      "scope": "text.jinja meta.placeholder.jinja",
      "background": "var(black)",
      // Have a consistent basic foreground colour regardless of whether the Jinja placeholder is itself inside a string.
      "foreground": "var(steel)"
    },

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // JSX Templating
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
      "scope": "(source.jsx | source.tsx) & meta.jsx meta.interpolation",
      "background": "var(black)"
    },

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Preprocessor Directives (or equivalent comment constructs)
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
      "scope": "source.ocaml meta.preprocessor , source.go comment.line meta.annotation",
      "foreground": "var(slate_light)",
      "background": "var(black)"
    },

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // File Paths and Line Numbers
    //   - Find Results panel
    //   - LSP panels
    //     - Diagnostics
    //     - References
    //   - Build Results panel
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "text.find-in-files & (entity.name.filename | constant.numeric.line-number.match) , output.lsp & (entity.name.filename | constant.numeric.line-number | constant.numeric.col-number) , text.build-results markup.location.build-results", "foreground": "var(steel)", "selection_foreground": "var(yellow_punchy)"},
    {"scope": "text.find-in-files constant.numeric.line-number", "foreground": "var(grey)"}, // "Context" lines

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Insertions and Deletions
    //   - Stock diffs
    //   - Override Audit diffs
    //   - https://github.com/SublimeText/UnitTesting results panel
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "markup.inserted", "foreground": "var(green)"},
    {"scope": "markup.deleted",  "foreground": "var(red)"},

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Results / Diagnostics
    // - Build Results panel
    // - LSP Diagnostics Panel
    //   - REF: https://lsp.sublimetext.io/customization/#diagnostics
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "markup.error",                    "foreground": "var(red)"},
    {"scope": "markup.warning",                  "foreground": "var(gold)"},
    {"scope": "markup.note",                     "foreground": "var(slate_light)"},
    {"scope": "markup.info",                     "foreground": "var(blue)"},
    {"scope": "markup.info.hint",                "foreground": "var(green)"},
    {"scope": "meta.error-header.build-results", "background": "var(black)"},

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Diagnostic
    // - LSP Diagnostics Highlights (in the view, e.g. squiggles)
    //   - REF: `DIAGNOSTIC_SEVERITY` in https://github.com/sublimelsp/LSP/blob/main/plugin/core/views.py
    //   - REF: `_draw_diagnostics` in https://github.com/sublimelsp/LSP/blob/main/plugin/session_view.py
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "region markup.error.lsp",     "foreground": "var(red_punchy)"}, // var(red) is a bit too faint when used for squiggly underlines.
    {"scope": "region markup.warning.lsp",   "foreground": "var(orange_punchy)"},
    {"scope": "region markup.info.lsp",      "foreground": "var(yellow_punchy)"},
    {"scope": "region markup.info.hint.lsp", "foreground": "var(white)"},

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Highlights / Underlines
    // - LSP hovered range (see LSP "hover_highlight_style" setting)
    //   - REF: https://lsp.sublimetext.io/customization/#hover-highlights
    // - LSP server-identified link (see LSP "link_highlight_style" setting)
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "markup.highlight.hover.lsp", "background": "var(grey_light)"},
    {"scope": "markup.underline.link.lsp",  "background": "var(white)"},

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // LSP: "Signature Help" popup (distinct from AutoComplete)
    // REF: https://lsp.sublimetext.io/customization/#signature-help
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "entity.name.function.sighelp.lsp",     "foreground": "var(steel)"}, // Function name, parens, commas, etc.
    {"scope": "variable.parameter.sighelp.lsp",       "foreground": "var(white_faded)"},
    {"scope": "variable.parameter.sighelp.active.lsp","foreground": "var(white)"},

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // LSP: Other visible occurences of the thing at the caret (see LSP "document_highlight_style" setting)
    // REF: https://lsp.sublimetext.io/customization/#document-highlights
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "markup.highlight.text.lsp",  "foreground": "var(white_faded)"},
    {"scope": "markup.highlight.read.lsp",  "foreground": "var(white_faded)"},
    {"scope": "markup.highlight.write.lsp", "foreground": "var(white_faded)"},

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // PackageDev
    // - Syntax Definition authoring
    // - Syntax Test authoring
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {"scope": "markup.info.capture.sublime-syntax", "background": "var(white_faded)"},
    {"scope": "markup.info.test.sublime-syntax",    "background": "var(white_faded)"},
  ]
}
